use std::ffi::c_ushort;
use std::fmt::Debug;
use std::ops::Index;
use rand::Rng;
#[derive(Debug)]
struct Rule {
    left_hand_side: char,
    right_hand_side: String
}

impl Rule{
    fn new (left_hand_side: char, right_hand_side: &str) -> Rule {
        Rule {
            left_hand_side,
            right_hand_side: right_hand_side.to_string(),
        }
    }

    fn is_rule_valid(&self) -> bool {
        return self.left_hand_side.is_ascii_uppercase();
    }

    fn rule_is_right_regular(&self) -> bool {
        let mut count = 0;
        for chars in self.right_hand_side.chars() {
            count += 1;
            if chars.is_ascii_uppercase() && count == 0 {
                return true;
            } else {
                break;
            }
        }
        return false;
    }

    fn rule_is_left_regular(&self) -> bool {
        let mut count = 0;
        for chars in self.right_hand_side.chars() {
            count += 1;
            if chars.is_ascii_uppercase() && count == self.right_hand_side.len() {
                return true;
            } else {
                break;
            }
        }
        return false;
    }
}

#[derive(Debug)]
struct Grammar {
    start_symbol: char,
    non_terminals: String,
    terminals: String,
    rules: Vec<Rule>
}

impl Clone for Grammar {
    fn clone(&self) -> Self {
        todo!()
    }
}

impl Grammar{
    fn from_rules(rules: Vec<Rule>) -> Grammar{

        //populate grammar attribs
        let start_symbol = rules[0].left_hand_side.clone();
        let mut non_terminals:Vec<char> = Vec::new();
        let mut terminals:Vec<char> = Vec::new();
        let mut rules_vec:Vec<char> = Vec::new();

        return Grammar {
            start_symbol,
            non_terminals: "".to_string(),
            terminals: "".to_string(),
            rules,
        }
    }

    fn grammar_is_valid(&self) -> bool {

        //need to check production rules, terminals, non-terminals still?
        if self.start_symbol.is_ascii_uppercase() {
            return true;
        }
        return false;
    }

    //determine if grammar is type 3, all prod rules need to be right reg or left reg but not both
    //return t/f based on if grammmar is right reg/ left reg
    fn grammar_is_regular(&self) -> bool{
        for nt in self.non_terminals.chars() {
            let right_regular = self.rule_indxs_from_nt(nt).iter().filter(|&i| self.rules[*i].rule_is_right_regular()).count();
            let left_regular = self.rule_indxs_from_nt(nt).iter().filter(|&i| self.rules[*i].rule_is_left_regular()).count();

            if right_regular > 0 && left_regular < 0{
                return false;
            }
        }
        return true;
    }

    fn rule_indxs_from_nt(&self, non_terminal:char) -> Vec<usize> {
        let mut rule_indices = Vec::new();
        for (index, rule) in self.rules.iter().enumerate(){
            if rule.left_hand_side == non_terminal {
                rule_indices.push(index);
            }
        }
        return rule_indices;
    }
}

enum DerivationError {
    IncompleteSentential
}
#[derive(Debug)]
struct Sentential {
    sentential: String,
    first_nt_index: i32
}

impl Sentential {
    fn new_initial(grammar: &Grammar, rule_index: i32) -> Sentential {
        return Sentential {
            sentential: grammar.start_symbol.to_string(),
            first_nt_index: 0
        }
    }

    fn new_next(g:Grammar, index: usize) -> Sentential {
        let index_rule = g.rules.index(index);
        let sentential = &index_rule.right_hand_side;


        return Sentential {
            sentential: "".to_string(),
            first_nt_index: 0,
        }
    }

    fn is_complete(&self) -> bool{
        //a check for if empty
        if self.sentential.is_empty() {
            return true;
        }

        //check for non-terminal symbols
        for character in self.sentential.chars() {
            if character.is_ascii_uppercase() {
                println!("{}", character);
                return false;
            }
        }
        return true;
    }
}


#[derive(Debug)]
struct Derivation {
    steps: Vec<(i32, Sentential)>,
    is_complete_flag: bool,
    //word: String
}

impl Derivation {

    fn new(g:Grammar) -> Derivation {
        let initial_sentential = Sentential::new_initial(&g, 0);
        let steps = vec![(-1, initial_sentential)];
        return Derivation {
            steps,
            is_complete_flag: false,
            //word: steps.first().
        }
    }

    fn derive_leftmost(&mut self, g: Grammar, index:usize){
        //use rng and rule_indxs_from_nt here
        //find leftmost nt

        let mut leftmost_nt = '0';
        let mut nts:Vec<char> = Vec::new();
        let symbols = g.rules.index(index).right_hand_side.chars();
        let mut count = 0;
        for character in symbols {

            //check for terminal
            if character.is_ascii_uppercase() {
                leftmost_nt = character;
                count+=1;
            }

            if character.is_ascii_uppercase() && count >= 1 {
                nts.push(character);
            }
        }
        //call rule_indxs_from_nt, pass leftmost nt
        let rules = g.rule_indxs_from_nt(leftmost_nt);

        //apply rule
        let new_sentential = Sentential::new_next(g, index);

        //add index and sentential result to step
        self.steps.push((index as i32, new_sentential));
        //return F if no more nts, set flag indicating that derivation is complete
        if nts.is_empty() {
            //return false;
        }
        //return true;
    }

    fn is_complete(&self) -> bool {// -> Vec<(i32, Sentential)> {
        //if sentential is_complete returns done return true
        //otherwise return the leftmost nt of the last step
        if self.is_complete_flag{
            return true;
        } else {
            //TODO: return leftmost nt
        }
        return false;
    }

    fn print_random() {
        //TODO: use rng to randomly selected a provided rule to apply
    }

    //fn word(&self) -> String{
        //return self.steps.index(0);
    //}
}
fn example_manual () {
    let rules = vec! {
        Rule::new('E', "E+e"),//.new('E',"E+e"),
        Rule::new('E',"x")
    };

    //for i in rules.iter(){
    //    println!("{:?}",i);
    //}

    let grammar:Grammar = Grammar::from_rules(rules);

    println!("grammar valid={:}",grammar.grammar_is_valid());
    println!("grammar regular={:}", grammar.grammar_is_regular());


    let mut deriv = Derivation::new(grammar.clone());
    deriv.derive_leftmost(grammar.clone(), 0);//.unwrap();
    deriv.derive_leftmost(grammar.clone(), 0);//.unwrap();
    deriv.derive_leftmost(grammar.clone(), 1);//.unwrap();

    println!("derivation complete {:?}", deriv.is_complete());
    //println!("derivation word {:?}",deriv.word());//.unwrap());

    /*
    while derivations < max_derivations && is_leftmost_nt {
        if(!derive_leftmost) {
            //break
        }

    }
     */
}


/*
let rng = rand::thread_rng();
let random_num = rng.gen_range(1..= (size of rule vector));
 */fn main() {
    example_manual();
}
