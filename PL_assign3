use std::ffi::c_ushort;
use std::fmt::Debug;
use std::ops::Index;
use rand::Rng;
#[derive(Debug, Clone)]
struct Rule {
    left_hand_side: char,
    right_hand_side: String
}

impl Rule{
    fn new (left_hand_side: char, right_hand_side: &str) -> Rule {
        Rule {
            left_hand_side,
            right_hand_side: right_hand_side.to_string(),
        }
    }

    fn is_rule_valid(&self) -> bool {
        return self.left_hand_side.is_ascii_uppercase();
    }

    fn rule_is_right_regular(&self) -> bool {
        let mut count = 0;
        for chars in self.right_hand_side.chars() {
            count += 1;
            if chars.is_ascii_uppercase() && count == 0 {
                return true;
            } else {
                break;
            }
        }
        return false;
    }

    fn rule_is_left_regular(&self) -> bool {
        let mut count = 0;
        for chars in self.right_hand_side.chars() {
            count += 1;
            if chars.is_ascii_uppercase() && count == self.right_hand_side.len() {
                return true;
            } else {
                break;
            }
        }
        return false;
    }
}

#[derive(Debug, Clone)]
struct Grammar {
    start_symbol: char,
    non_terminals: String,
    terminals: String,
    rules: Vec<Rule>
}

impl Grammar{
    fn from_rules(rules: Vec<Rule>) -> Grammar{

        //populate grammar attribs
        let start_symbol = rules[0].left_hand_side.clone();
        println!("start symbol is {:}", start_symbol);

        let mut non_terminals:Vec<char> = Vec::new();
        for rule in rules.iter() {
            for character in rule.right_hand_side.chars() {
                if character.is_ascii_uppercase() {
                    non_terminals.push(character);
                }
            }
        }

        let mut terminals:Vec<char> = Vec::new();
        for rule in rules.iter() {
            for character in rule.right_hand_side.chars() {
                if character.is_ascii_lowercase() {
                    terminals.push(character);
                }
            }
        }
        let mut rules_vec:Vec<Rule> = rules.clone();

        return Grammar {
            start_symbol,
            non_terminals: "".to_string(),
            terminals: "".to_string(),
            rules,
        }
    }

    fn grammar_is_valid(&self) -> bool {

        //need to check production rules, terminals, non-terminals still?
        if self.start_symbol.is_ascii_uppercase() {
            return true;
        }
        return false;
    }

    //determine if grammar is type 3, all prod rules need to be right reg or left reg but not both
    //return t/f based on if grammmar is right reg/ left reg
    fn grammar_is_regular(&self) -> bool{
        for nt in self.non_terminals.chars() {
            let right_regular = self.rule_indxs_from_nt(nt).iter().filter(|&i| self.rules[*i].rule_is_right_regular()).count();
            let left_regular = self.rule_indxs_from_nt(nt).iter().filter(|&i| self.rules[*i].rule_is_left_regular()).count();

            if right_regular > 0 && left_regular < 0{
                return false;
            }
        }
        return true;
    }

    fn rule_indxs_from_nt(&self, non_terminal:char) -> Vec<usize> {
        let mut rule_indices = Vec::new();
        for (index, rule) in self.rules.iter().enumerate(){
            if rule.left_hand_side == non_terminal {
                rule_indices.push(index);
            }
        }
        return rule_indices;
    }
}

enum DerivationError {
    IncompleteSentential
}
#[derive(Debug, Clone)]
struct Sentential {
    sentential: String,
    first_nt_index: i32
}

impl Sentential {
    fn new_initial(grammar: &Grammar, rule_index: i32) -> Sentential {
        return Sentential {
            sentential: grammar.start_symbol.to_string(),
            first_nt_index: 0
        }
    }

    fn new_next(g:Grammar, index: usize) -> Sentential {
        let index_rule = g.rules.index(index);
        let sentential = &index_rule.right_hand_side;

        return Sentential {
            sentential: sentential.to_string(),
            first_nt_index: 0,
        }
    }

    fn is_complete(&self) -> bool{
        //a check for if empty
        if self.sentential.is_empty() {
            return true;
        }

        //check for non-terminal symbols
        for character in self.sentential.chars() {
            if character.is_ascii_uppercase() {
                println!("{}", character);
                return false;
            }
        }
        return true;
    }
}


#[derive(Debug)]
struct Derivation {
    steps: Vec<(i32, Sentential)>,
    is_complete_flag: bool,
}

impl Derivation {

    fn new(g:Grammar) -> Derivation {
        let initial_sentential = Sentential::new_initial(&g, 0);
        let steps = vec![(-1, initial_sentential)];
        return Derivation {
            steps,
            is_complete_flag: false,
        }
    }

    fn derive_leftmost(&mut self, mut g: Grammar, index:usize){
        //use rng and rule_indxs_from_nt here
        //find leftmost nt

        let mut leftmost_nt = '0';
        let mut nts:Vec<char> = Vec::new();
        let symbols = g.rules.index(index).right_hand_side.chars();
        println!("symbols: {:?}",symbols);
        let mut count = 0;
        for character in symbols {

            //check for terminal
            if character.is_ascii_uppercase() {
                leftmost_nt = character;
            }

            if character.is_ascii_uppercase() && count >= 1 {
                //nts.push(character);
                //println!("pushd additional character to nts vector {:}", character);
            }
        }
        //call rule_indxs_from_nt, pass leftmost nt
        let rules = g.rule_indxs_from_nt(leftmost_nt);

        //apply rule
        //g.rules = rules;
        //maybe loop throughg.rules and apply specific rules throigh rule_indices
        //no because the only place I actually apply rules is outside of the method
        //instead I need to load rules to be ready to be used
        let new_sentential = Sentential::new_next(g, index);
        println!("Newest sentential is {:?}", new_sentential);

        //add index and sentential result to step
        self.steps.push((index as i32, new_sentential));
        //return F if no more nts, set flag indicating that derivation is complete

        //return true;
    }

    fn is_complete(&self) -> bool{// -> Vec<(i32, Sentential)> {
        //if sentential is_complete returns done return true
        //otherwise return the leftmost nt of the last step

        /*
        if self.is_complete_flag{
            return true;
        } else {
            //TODO: return leftmost nt, but I can't because it returns only bool...
        }
        return false;
        */

        //seecond way of doing it
        //check for nts by looping through rules in vector
        /*for step in self.steps {
            for sentential in step.1.it {
                for characters in sentential {
                    println!("{}", characters);
                }
            }
        }

         */

        //I think I'm overthinking this, just gonna run with code below
        let vector_size = self.steps.len()-1;
        let last_sentential = &self.steps[vector_size].1;
         for character in last_sentential.sentential.chars() {
            if character.is_ascii_uppercase() {
                return false;
            }
        }
        return true;
    }

    fn print_random() {
        //TODO: use rng to randomly selected a provided rule to apply, not sure if this is its own function or a function of Derivative

        //rules

        //probabilities of rules

        //derive until we hit max num of steps
    }

    fn word(&self) -> &String {
        let last_index = self.steps.len()-1;
        let sentential = &self.steps[last_index].1;
        return &sentential.sentential;
    }

    fn leftmost_nt(&self){
        //not gonna put anything here for now as my derivation is actually working and I want to have the assignment finished before I go breaking it again by adding stuff
    }
}
fn example_manual () {
    //want result of c-(c/c)
    let rule_set_2 = vec! {
        Rule::new('A', "A-B"), //0
        Rule::new('A', "B"),   //1
        Rule::new('B', "B/C"), //2
        Rule::new('B', "C"),   //3
        Rule::new('C', "(B)"), //4
        Rule::new('C', "c")    //5
    };

    //for i in rules.iter(){
    //    println!("{:?}",i);
    //}

    let grammar2:Grammar = Grammar::from_rules(rule_set_2);

    println!("grammar valid= {:}", grammar2.grammar_is_valid());
    println!("grammar regular= {:}", grammar2.grammar_is_regular());

    let mut deriv2 = Derivation::new(grammar2.clone());
    deriv2.derive_leftmost(grammar2.clone(), 0); //A
    deriv2.derive_leftmost(grammar2.clone(), 1); //A-B
    deriv2.derive_leftmost(grammar2.clone(), 5); //c-B
    deriv2.derive_leftmost(grammar2.clone(), 3); //c-C
    deriv2.derive_leftmost(grammar2.clone(), 4); //c-(B)
    deriv2.derive_leftmost(grammar2.clone(), 2); //c-(B/C)
    deriv2.derive_leftmost(grammar2.clone(), 3); //c-(C/C)
    deriv2.derive_leftmost(grammar2.clone(), 5); //c-(c/C)
    deriv2.derive_leftmost(grammar2.clone(), 5); //c-(c/c)

    println!("derivation complete {:?}", deriv2.is_complete());
    println!("derivation word {:?}",deriv2.word());//.unwrap());

}


/*
let rng = rand::thread_rng();
let random_num = rng.gen_range(1..= (size of rule vector));
 */fn main() {
    example_manual();
}
