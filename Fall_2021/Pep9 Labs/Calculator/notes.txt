 / 8 2 = 4
 / 10 5 = 2

/ 10 4 = 2 (int math truncated)

/ 99 100 = 0
/100 99 = 1

no .word, .byte, .block
all signed integer math is not to be rounded

square roots can be estimated iteratively. If the user inputs any negative number, print an error

main: 
		push 1st param			
		push 2nd param
		call Add
		pop
		pop
		call Subtract




Add:		SP +2			;subroutine
		SP +4

		LDWD _,s
		ADDA _,s
		BRV		;branch if overflow bit		
RET	

Subtract:
Multiply:
;example 3 * 7
Accumulator holds operand, X reg counts loop
RET

Division	
;example 7 / 3
;7-3 = 4
;4-3 = 1
;1-3 = -2
Accumulator holds result, X reg counts how many times it loops

faster way could be
5000 * 2...arithmatic shift if power of 2
2nd best way is to add 5000 twice
worst way is to add 2 5000 times


operands can be positive or negative, USE SIGNED VERSIONS
if an operand is negative, store the sign of the neg number, and make everything positive

use 2's complement to negate

Square root...
Assuming multiplication works
SQRT 16

keep multiplying sqaures until I find a number that is close


Errors
---------------------------------
addition, subtraction, multiplication can all provide errors
For addition and subtraction, can use BRV

;ex: 5 * 10000

for mult and division check each iteration for V being set

Bilitski will not put numbers in that are out of range

INPUT:
will only be in pre-fix

Test driven development: move on basis that current code does not provide an error each test

Notes: Do add first, other operations depend on it...Do NOT branch out of a subroutine, use a RET
PROGRAM--------------------------------------------------------------------
get operation
get input 1
get input 2

check operation
	if number is +, CALL Add
	if number is -, CALL Sub
	if number is *, CALL Mul
	if number is /, CALL Div

;printing output
print operand, input 1, input 2, equal sign, result
print dashes



multiplication
check operand 1 to see if neg
if so...
	apply 2's complement
	(A)save 1/0 to stack to mark whether to make result pos or not <--(I think its better just to write twice than make a subroutine for)
check operand 2 to see if neg
if so...
	apply 2's complement
	(B)save 1/0 to the stack...

is op1 > op2?
if so...
	go into multiplication loop with operand1 adding to itself (operand2) times
	(C)save 1/0 to stack to mark.

else...
	go into loop with operand2 adding to itself (operand1) times
	(D)save 1/0 to stack to mark.(maybe byte after)

multiplication loop
check spot 'A'
	if 1 then use operand1
	otherwise use operand2

check spot 'C'
	if 1 use operand1
	otherwise use operand2

FFFF
0000
	1
1

-1
0001
FFFF

divison
/ 	10 		5
op	operand1	operand2

load operand 1
subtract operand 2 from operand1
is result =0?
if so...
	exit loop
is result <


Square root
s 16 4
operand 1 is 16


;instead of comparing it to something, instead do this
;we want to multiply 4 until we get 16, so we call multiply in a loop.
;every iteration we check to see if the result is < to 16. If it is, we continue looping
;However, if the current result is > 16 then we divide once and return that.
;Say operand 1 is 33. 
;	we square 1.
;	is 1 = 33? No, so we try 1+1
;	we square 2.
;	4 != 33 so we try 2+1
;	sqaure 3
;	9 != 33
;and so on...
;now we reach 5
;	we square it to get 25
;	25 != 33
; square 6 to get 36
; 36 > 33
;since 36 > 33, we exit the loop and branch to a seperated piece of code 
;here we will take operand 2 which equals 6 and subtract 1, which gets 5
; thus the answer is 5

Save operand 1 somewhere (call it -getOp1-)
Overwrite operand 1 w/ operand 2
Call multiply...<-- this will square operand 2

