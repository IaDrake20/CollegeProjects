SortAndCombine {

	make ArrayQueue <integer>, add integers to it from user inputs
	
ArrayQueue <Integer> intUserInputs = new ArrayQueue <Integer>();

//Scanner input
//ask for input
while(isFinished){
intUserInputs = input.nextInt();
//ask if they want to stop
int totalInputs_1 ++;
}

second idea is to use String Tokenizer

	make a second ArrayQueue<Integer>, add integers to it from user input
//just do the same thing as the first one
//have int totqlInputs_2 increment in same place

	put the items in intUserInputs into an array, they should be sorted low ints to high ints
new int[] array of the same size as totalInputs_1
load inputs through a for loop
something like for(int i = 0; i < newArray.length -1; i++) {
			newArray[i] = intUserInputs_1.dedqueue();
			//have some way of sorting the values as they are indexed
}


//repeat for second ArrayQueue

	Enqueue thru a for loop the indexes, assigning them to intUserInputs_1
for(int i = 0; i < newArray.length -1; i++) {

			intUserInputs_1.enqueue(newArray[i]);
}

//pretty much same thing for secondArrayQueue



2,3,4

I want to put 1 into queue
1 < 2, so enqueue

1,2,3,4
I want to put 5 into queue
5 > 1, so dequeue to temp[]
5 > 2, so dequeue to temp[]
5 > 3, so dequeue to temp[]
5 > 4, so dequeue to temp[]
enqueue 5

for (int i = 0; i != highestNum; i++) {
	
	//if x is greater/equal than the number before it, put it after that number
	//issue is that it needs to keep checking until the next number is null or is less than x
	if (x > queue.getFront()){

		intList[i] = queue.dequeue();
		++count;
	}
	else if( queue.getFront == null || x == queue.getFront()){
		queue.enqueue(x);
		for(int i = 0; i < count; i++) {
			queue.enqueue(intList[j]);
		}
	}

	//if x is less than the number before it, enqueue normally
	else {

		queue.enqueue(x);
	}

	
	
